### BaekJoon 알고리즘 Dynamic Programming 풀이
- 1로 만들기 문제
    - 문제 번호 : 1463
    - <a href="https://www.acmicpc.net/problem/1463">문제 참조</a>
        - 내용 : X의 값을 1로 만들 수 있는 최소의 연산 횟수 구하기(3 또는 2로 나누거나 1을 빼는 행위 가능)
        - 풀이
            - 1에 가까운 수부터 1로 만들 수 있는 최소의 횟수를 구한 뒤 점점 큰 수에 대해 동일 연산을 수행하여 해당 연산에 따른 결과값의 연산 횟수에 1을 더한 것 중 최소 값을 배열에 저장
            - 2를 1로 만드는 것은 1을 빼는 1회
            - 3을 1로 만드는 것은 1을 빼면 2가 되고 2의 최소 연산은 1이므로 2회, 또는 3을 3으로 나누어 1로 만드는 1회 연산, 둘 중 작은 것은 1회
            - 4를 1로 만드는 것은 1을 빼면 3의 최소 연산인 1 + 1 = 2회 또는 2로 나누면 2의 최소 연산인 1 + 1 = 2회, 작은 것은 2회
            - 위와 같이 dp 배열에 저장해 두어 풀이
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon1463.java">답안</a>

- 이친수 개수 구하기
    - 문제 번호 : 2193
    - <a href="https://www.acmicpc.net/problem/2193">문제 참조</a>
        - 내용 : 이진수 중 0으로 시작하지 않고 1이 연속 두 번 나오지 않는 것이 이친수이며 N자리의 이친수 개수를 구한다.
        - 풀이
            - 쉬운 계단 수와 동일한 방식으로 해결할 수 있다.(10844번)
            - 2차원 배열을 이용해 1차원에는 N의 자리수, 2차원에는 0 또는 1로 끝나는 이친수의 개수를 지정한다.
            - 만약 1자리 수 이친수가 0 또는 1로 끝난다면, dp[1][0] = 0, dp[1][1] = 1이다.
            - 이 때, dp[N][0] = dp[N-1][0] + dp[N-1][1], dp[N][1] = dp[N-1][0]이 된다.


- 1,2,3 더하기 문제
    - 문제 번호 : 9095
    - <a href="https://www.acmicpc.net/problem/11726">문제 참조</a>
        - 내용 : 정수 n을 1, 2, 3의 합으로 나타낼 수 있는 경우의 수 구하기
        - 풀이
            - 정수 1~3까지는 몇 가지 되지 않으니 쉽게 표현을 미리 지정해 배열에 선정할 수 있다.
            - 4부터는 해당 정수의 1~3까지 작은 숫자에서 하나의 숫자만 더하는 것이므로 그 작은 숫자를 나타낼 수 있는 경우의 수를 모두 더하면 된다.
            - 즉, dp[4] = dp[3] + dp[2] + dp[1] 과 같이 표현할 수 있다.
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon9095.java">답안</a>

- 쉬운 계단 수
    - 문제 번호 : 10844
    - <a href="https://www.acmicpc.net/problem/10844">문제 참조</a>
    - 내용 : 0으로 시작할 수 없는 숫자의 길이가 주어지며 그 숫자의 각 자리수는 1씩 차이가 나는 계단 수이다. 숫자의 길이가 주어질 때, 계단 수의 수를 구하라.
    - 풀이
        - 2차원 배열을 이용해서 숫자의 길이와 1의 자리 숫자를 지정하는 것을 index로 지정하면 된다.
        - 숫자 길이가 1이면 1의 자리 0인 경우 빼고 모두 1이다. 즉, dp[1][1]~dp[1][9] = 1이다.
        - 그 이후 dp[n][0] = dp[n-1][1], dp[n][9] = dp[n-1][8], dp[n][i] = dp[n-1][i-1] + dp[n-1][i+1](i는 1~8)
        - 이를 통해 구현을 수행한다.

- 카드 구매하기
    - 문제 번호 : 11052
    - <a href="https://www.acmicpc.net/problem/11052">문제 참조</a>
        - 내용 : 가챠 카드팩을 N장 구매하기 위해 돈을 사용. 이 돈을 최대로 사용하는 경우의 금액 구하기
        - 풀이 
            - 각 카드팩을 구매 시 n장을 산다면 n장 짜리 1개 혹은 n-x(1 <= x <= n-1장의 조합으로 구매할 수 있다.
            - 그렇다면 1장만 구매 시 부터 n장을 구매 시까지 dynamic_programming으로 정답을 구할 수 있다.
            - 4장을 사고 각 장 수 만큼 든 카드팩의 비용을 1, 5, 6, 7이라 하자.
            - 1장만 산다면 1을 지불하는 것이 가장 비용을 많이 쓰는 것이다.
            - 2장을 산다면 1장을 2개 혹은 2장 팩을 1개 산다고 생각 시, dp[2] 또는 dp[2-1] + dp[1] 이라고 볼 수 있다.
            - 즉, dp[n] = dp[n-i] + dp[i]로 지정하면 된다.(1 <= i <= n)
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon11052.java">답안</a>

- 2*1 타일 채우기 문제
    - 문제 번호 : 11726
    - <a href="https://www.acmicpc.net/problem/11726">문제 참조</a>
        - 내용 : 2\*n 사각형 타일을 1\*2 / 2\*1의 타일로 채우는 경우의 수 구하기
        - 풀이
            - 2\*1을 채우는 방법은 1개, 2\*2를 채우는 방법은 2개이다.
            - 2\*3의 경우 이후에 2\*1(세로로 긴 방향)으로 모두 채우는 방법은 2\*1을 채우는 방법과 같으며, 나머지는 가로로 두개, 세로 하나를 놓는 2가지로 총 3가지이다.
                - 2\*3은 2\*1과 2\*2를 채우는 두 경우의 수의 합과 같다.
                - 즉, 가로로 채우는 방법과 세로로 채우는 방법의 합이 답이 된다.
            - 2\*4의 경우 하나를 세로로 채운다면 나머지는 2\*3을 채우는 방법과 같은 방식으로 채우는 것만 남게 된다. 두 가지를 세로로 채우면 2\*2를 채우는 방법과 같다.
                - 3개를 세로로 채우는 것은 1개를 세로로 채우는 것과 중복이 된다. 따라서 2*\4도 2\*3 + 2\*2와 같은 방식으로 구할 수 있다.
            - 즉, dp[n] = dp[n-1] + dp[n-2]가 답이 된다.
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon11726.java">답안</a>

- 2*1 타일 채우기 문제2
    - 문제 번호 : 11727
    - <a href="https://www.acmicpc.net/problem/11727">문제 참조</a>
        - 내용 : 2\*n 사각형 타일을 1\*2 / 2\*1, 2\*2의 타일로 채우는 경우의 수 구하기
        - 풀이
            - 11726의 문제와 풀이 방식은 비슷한데 2\*2가 추가된 것
            - 그런데 잘 생각해보면 기존의 채울 수 있는 방식에 2\*2만 추가되었으므로 그 부분만 고려하면 됨
            - 그래서, 2\*2로 채울 수 있는 방법은 한 부분이 2\*2로 채워졌다는 가정하에 생각 시 2*\n 크기라면 2\*(n-2)를 채우는 방법과 동일함
            - 즉, dp[n] = dp[n-1] + 2 * dp[n-2]가 답이 된다.
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon11727.java">답안</a>

- 1,2,3 더하기 2
    - 문제 번호 : 15990
    - <a href="https://www.acmicpc.net/problem/15990">문제 참조</a>
    - 내용 : 정수 n을 1, 2, 3의 합으로 나타낼 수 있는 경우의 수 구하기(중복되는 수 연속 사용 불가)
        - 풀이
            - 정수 1~3까지는 몇 가지 되지 않으니 쉽게 표현을 미리 지정해 배열에 선정할 수 있다.
            - 4부터는 3을 만들 시, 마지막 수가 2 또는 3인 경우, 2를 만들 시 마지막 수가 1 또는 3인 경우, 1을 만들 시 마지막 숫자가 1 또는 2인 경우만이 존재한다.
                - 즉, 2차원 배열을 만들면 dp[4][1] = dp[3][2] + dp[3][3], dp[4][2] = dp[2][1] + dp[2][3], dp[4][3] = dp[1][1] + dp[1][2] 이다.
                - 즉, 2차원 배열에서 두 번째 index는 마지막으로 더해진 숫자를 의미한다고 생각하면 된다.
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon15990.java">답안</a>

- 카드 구매하기2
    - 문제 번호 : 16194
    - <a href="https://www.acmicpc.net/problem/16194">문제 참조</a>
        - 내용 : 가챠 카드팩을 N장 구매하기 위해 돈을 사용. 이 돈을 최소로 사용하는 경우의 금액 구하기
        - 풀이 
            - 각 카드팩을 구매 시 n장을 산다면 n장 짜리 1개 혹은 n-x(1 <= x <= n-1장의 조합으로 구매할 수 있다.
            - 그렇다면 1장만 구매 시 부터 n장을 구매 시까지 dynamic_programming으로 정답을 구할 수 있다.
            - 4장을 사고 각 장 수 만큼 든 카드팩의 비용을 1, 5, 6, 7이라 하자.
            - 1장만 산다면 1을 지불하는 것이 가장 비용을 적게 쓰는 것이다.
            - 2장을 산다면 1장을 2개 혹은 2장 팩을 1개 산다고 생각 시, dp[2] 또는 dp[2-1] + dp[1] 이라고 볼 수 있다.
            - 즉, dp[n] = dp[n-i] + dp[i]과 i장짜리 팩 하나를 사는 것 중 작은 것으로 지정하면 된다.(1 <= i <= n)
    - <a href="https://github.com/hongjw1991/Java-DataStructure-Algorithm-DesignPattern/tree/master/Algorithm/Problem_Solve/1. Dynamic Programming/BaekJoon/BaekJoon16194.java">답안</a>
